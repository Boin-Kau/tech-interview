# Process

OS의 작업 단위: process  
하나의 프로세스가 실행되기 위해 필요한 자원: CPU, 메모리, file, I/O장치  
OS가 하는 일: 프로세스 관리  
<br>

### 프로세스의 메모리 레이아웃
1. text section - 실행가능한 코드
2. data section - 전역 변수들
3. heap section - 동적 할당되는 메모리
4. stack section - 함수 호출을 하면 스택에 쌓임  
<br>

argc(argument count), argv(argument vector)
main 함수를 호출하면 main 함수가 스택에 쌓이면서 값이나 변수들을 스택 영역에 확보함.
malloc을 해서 값을 할당하면 heap 영역에 메모리 확보.
실행 코드들은 text section에.
return 0 해서 끝나면 main 함수가 운영체제한테 제어권을 돌려줌.

### 프로세스의 생명 주기(life cycle):
>1. New - 막 이 프로세스가 생성된 상태
>2. Running - CPU를 프로세스가 점유해서, 프로세스 명령어를 CPU에 로드해서 실행하는 상태
>3. Waiting - 타임셰어링으로 CPU 점유해서 쓰다가, 다른 프로세스가 들어오면 다른 프로세스는 기다리고 있는 상태
>4. Ready - I/O 완료 대기하고 있다가, 완료하면 그때 바로 CPU를 점유할 수 있는게 아니다. 따라서 레디 큐에 가서 점유할 수 있는 대기상태가 된 것이 Ready.
>5. Terminated - 모든 실행을 끝난 상태


cf. fork(): 새 프로세스 생성  
할 일이 없을 때는 웨이팅 큐에서 대기  
**process state Diagram**  
너무 오래하고 있으면 interrupt  
scheduler dispatch

<br>

## PCB
프로세스를 관리하는 가장 좋은 방법: PCB(Process Control Block)라는 구조체 생성  
구조체 안에 프로세스가 가져야 하는 모든 정보를 다 저장 => PCB, TCB(Task Control Block)

> PCB에 저장된 정보 중 알아야 하는 것:
1. Process state (new/run/wait/ready/terminate)
2. Program counter  : IR(Instruction Register)를 fetch할 곳 - 어디 pc에 해당하는 메모리를 가져와야 하는지
3. CPU registers  - IR, DR (, pc도 일종의 CPU register)
4. CPU를 주고받기 위해 필요한 스케줄 정보
5. 메모리 관리 정보
6. 계정 정보
7. 입출력 상태 정보
=> PCB들을 운영체제가 관리

<br>

### 스레드(Thread)
프로세스: 싱글 스레드를 수행하는 프로그램  
싱글 스레드는 한번에 한 태스크만 수행 가능  
프로세스가 한번에 여러 스레드를 실행 - 멀티태스킹(멀티프로세스)  
*`운영체제의 핵심적인 기능: 멀티태스킹, 멀티프로세싱을 제공`  
프로세스 안에서도 싱글 스레드 실행으로는 부족하더라 -> 프로그램이 복잡해지면서 여러개 스레드가 동시 실행될 필요가 많아짐 => 스레드 등장  
*`스레드: 프로세스보다 더 가벼운 프로세스.` 하나의 프로세스에서도 여러 스레드로 쪼개서 실행.   
지금은 멀티스레드가 대세. 병렬처리에는 멀티스레드로.

<br>

### [멀티프로그래밍의 목적]
>"동시에" 여러개의 프로세스를 실행시키자 -> CPU 사용 효율을 최대화하기 위해.  
>'타임셰어링'하는 이유: CPU 코어를 프로세스간에 자주 변경해서 사용자 입장에서 >프로그램이 동시에 돌고있는 것처럼 보이게 하기 위함. => `CPU를 스케줄링` 해야함  
<br>

### [스케줄링 큐(FIFO)]
CPU는 하나이기 때문에 프로세스가 순서대로 대기하고 있다가, CPU가 사용가능하면 그때 CPU를 획득 => ready queue
레디큐에서 타임이 끝나면 또다시 레디큐로 돌아가서 대기. I/O가 있으면 웨이팅큐로 가서 대기(wait queue를 나오면 레디큐로 감).
실제 구현은 PCB linked lists로.
레디큐와 웨이팅큐를 이용하여 CPU 스케줄링 가능.

<br>

### OS의 또다른 일 - `[context switch]`
>프로세스가 사용되고 있는 상태를 컨텍스트라 하는데, 그 상태가 다 PCB에 저장되어 있음 - PCB를 문맥이라고 봄.  
현재 컨텍스트를 저장해놓고(pc-어디까지 실행했는지), resume(CPU 다시 획득)했을 때 저장해놓은 컨텍스트를 restore(복원).  
context switch(문맥 교환) : `태스크가 CPU 코어를 다른 프로세스에 넘겨주는 것`  
=> 현재 프로세스의 상태를 `저장(save)`하고, 새로 프로세스를 획득할 프로세스의 상태를 `복원(reload)`한다.

<br>

*타임셰어링, 멀티프로세싱은 OS의 문맥 교환으로 이루어진다.  
OS 서비스를 통해 프로세스를 생성하고 종료한다.  
프로세스가 새로운 프로세스를 생성할 수 있다.  
프로세스 생성하는 프로세스: 부모 프로세스 - fork()로 수행  
프로세스에 의해 생성되는 프로세스: 자식 프로세스  
-> 프로세스 트리 관계 성립

<br>

#### 실행의 두가지 경우
1. 부모가 자식과 함께 concurrently 실행
2. 부모가자식을 탄생시킨 후 자식이 끝낼 때까지 wait

#### address-space의 두가지 경우  
// 부모와 자식이 똑같은 일을 수행한다면 PCB(pc)만 따로 하고
1. 자식은 부모 프로세스와 중복
2. 새로운 프로그램을 load

#### 프로세스 종료
1. final statement - return
2. exit()
3. OS가 메모리, 파일, 입출력버퍼 등등 모두 해제

#### 좀비, 고아 프로세스  
부모가 wait 호출하지 않고 종료하는 경우 - 자식은 `좀비 프로세스`가 되어 정보가 메모리에 남아있음  
부모가 wait을 호출하는 대신에 그냥 종료하는 경우 - 자식은 `고아 프로세스`가 됨 - init 프로세스가 새로운 부모 프로세스를 만들어 관리해줌  
`wait()` 시스템 호출을 해야 부모가 자식 프로세스가 종료할 때까지 기다릴 수 있다.  
daemon(background) process를 만들 때 주로 사용함


#### UNIX 계열 OS의 경우  
주소 공간을 복사해서 자식 프로세스 만든다.  
이 두 프로세스는(부모, 자식) fork() 호출 이후의 명령을 실행한다.  
fork()했을 때의 리턴코드가 0이면 자식 프로세스, OS커널이 부여한 (0이 아닌) pid(자식 프로세스의 pid)를 리턴해주면 부모프로세스다.  

#### fork() system call 이후
부모 프로세스는 자식을 생성 후, 자식이 도는 동안 할일이 없으면 종료하지 않고 wait()를 호출한다  
-> 레디큐에서 빼내서 wait 큐로 보내서, 자식 프로세스가 종료 후 inturrupt를 걸어주길 기다린다.  
=> 자식프로세스 리턴 후 부모 프로세스 리턴. 자식이 CPU 반납 후 부모가 다시 CPU 점유.  
자식은 부모 전역변수를 물려받지만, 부모는 그렇지 않음(예제 3.1의 경우).  
fork() 3번 하면 프로세스는 8개 -> 2의 n승  


#### 프로세스를 새로 만드는 용도:
P0(a.out)과 전혀 다른 일을 하고싶은데
execlp: b.out이라는 프로그램을 메모리에 덮어씀 => 부모 내용에서 execlp 이후의 문장은 b.out에 없기 때문에 아무 의미 없음.실행 안됨.
자기 pid 받아오기: getpid();

cf. 아주 극히 예외적인 상황: 하필이면 CPU가 fork() 바로 이후 context switch를 하면 자식 이후 부모가 실행될 수 있음 => `Synchronization` 필요  


---
```
OS 스케줄러 = CPU 스케줄러  
-> concurrent(동시에)하게 실행시키기 위해 time-sharing을 한다  
=> 이걸 하기 위해 레지스터 정보들을 저장/복원하는 context switch를 한다  
-> 컨텍스트 스위치를 하기 위해서는 Synchronization(동기화)를 잘 해줘야 한다.  
concurrency 환경이 (동시성 제어) 많은 문제를 일으키기 때문
```
<br>
week3: 프로세스와 프로세스 간 통신
IPC(inter process communication)